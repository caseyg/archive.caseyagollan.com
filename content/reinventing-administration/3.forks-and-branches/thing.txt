title: Forks and Branches
----
content:
If you remember the acronym for Git-like software: Distributed Version Control Systems, a feature called "forking" represents the D.  In Git-speak, the folder that you put your work in is called your "repository". What makes Git distributed is that anybody can make a copy of your repository onto their own computer to edit as they please. With or without Git anybody can copy anything they want off of the internet onto their computer and change it around, but forking in Git is distinct because Git "clones" the repository in its entirety and keeps those files linked to where they came from. Forking is somewhat self-explanatory in that you are basically creating a fork in the road of that particular repository. One path will continue to be forged by whoever you are copying from (Cooper Union's Administrative Documents), the other by you with your own newly cloned repository (Casey's Administrative Documents). In a similar way to how Git's version control collates the history of changes to a file, Git's forks link different people's versions of a file, allowing you to traverse possibilities. As you can see in the level of abstraction and the shift towards less familiar terminology — repository, fork, clone — this is where Git departs from existing paradigms about how we work. 

Unlike any old copy of a bunch of files, a Git feature called a “pull request” lets you package changes you make on your own computer and submit them back to the original repository’s owner for inclusion. Whether you spot a typo or feel like you need to write your own version of the FAQ with new content and a different tone, Git encourages direct action over indirect feedback. When you submit a pull request, the owners of the repository you forked are presented with a diff of your changes as well as your commit messages describing your intent. If the owners find your changes agreeable, Git can merge your versions automatically (noting in both repositories, of course: who, what, when, and why).

Forks can also be forked, merged, and pulled. For example, you fork the FAQ because you have a better answer to a particular question, and somebody else forks your FAQ to fix a typo. The collaboratively written and copy-edited FAQ can be submitted as a pull request to the owner of the official repository. Even if these systems are only used internally they start to break down barriers to getting work done, but this model becomes especially vibrant when the whole community or the whole world is invited to collaborate. The idea of a potentially unlimited number of forks out there that can be merged back into a repository may seem a little overwhelming and dangerous. Is it wise to let a stranger contribute to a Financial FAQ? Who gets to decide if and when to fold in their changes? That’s where a Git feature called branches comes in. 

Branches are like forks inside of a Git repository. If forks show you everyone’s version of a repository, branches show you ideas that are being worked on within a repository. Looking at the branches of an official repository is a good way to see what’s being worked on and considered within an organization. Using branches well is key to being respectful of community input. If the main branch, called the “master”, is literally the documents and information on which an organization acts, branches can represent drafts of every new idea, upcoming change, or proposed merge from an external fork. By working in branches, and never applying changes to the master before they have been approved by a vote or a test, the community is given time and space to offer feedback on ideas. Using branches as public testbeds might prevent more incidents where the community feels blindsided by administrative decisions that seem to come out of nowhere, having been made under secrecy or sometimes unintended opacity.